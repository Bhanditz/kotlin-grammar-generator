expression
  : attributes expression
  : "(" expression ")" // see tupleLiteral
  : literalConstant
  : functionLiteral
  : tupleLiteral
  : "this" ("<" type ">")?
  : expressionWithPrecedences
  : match
  : if
  : try
  : "typeof" "(" expression ")"
  : "new" constructorInvocation // TODO: Do we need "new"?, see factory methods
  : objectLiteral
  : declaration
  : jump
  : loop
  // block is syntactically equivalent to a functionLiteral with no parameters
  ;

literalConstant
  : "true" | "false"
  : StringWithTemplates
  : NoEscapeString
  : IntegerLiteral
  : HexadecimalLiteral
  : CharacterLiteral
  : "null"
  ;

declaration
  : function
  : property
  : extension
  : class
  : typedef
  ;

expressionWithPrecedences // See the precedence table, everything associates to the left
  : memberLiteral
  : memberAccessExpression
  : infixFunctionCall
  : binOpExpression
  : assignment
  : unOpExpression
  : castExpression
  : typingExpression
  ;

memberLiteral
  : expression? '#' SimpleName
  ;

memberAccessExpression
  : (expression accessOp)? (memberAccess | expression)
  ;

accessOp
  : "."
  : "?."
  ;

typingExpression
  : expression typingOperation type
  ;

typingOperation
  : "as"
  : "is"
  : "isnot"
  : ":"
  ;

binOpExpression
  : expression binaryOperation expression // see priorities
  ;

binaryOperation // Decreasing precedence
  : "." : "?." : "#"
  // unary
  : "*" : "/" : "%"
  : "+" : "-"
  // No << >> >>>
  : ".."
  : SimpleName
  : "?:"
  : "in" : "is" : "!in" : "!is" : "as" : ":"
  : "<" : ">" : ">=" : "<="
  : "!=" : "==" : "===" : "!=="
  // No | & ^ ~
  : "&&"
  : "||"
  : "match"
  : "->"
  : assignmentOperator
  ;

assignmentOperator
  : "="
  : "+=" : "-=" : "*=" : "/=" : "%="// TODO: |=, %= and <<= make more sense than |, % or << alone, and so for others
  ;

assignment
  : memberAccessExpression assignmentOperator expression // Assignment to functions prohibited by a semantic check
  ;

unOpExpression
  : expression postfixUnaryOperation
  : prefixUnaryOperation expression
  ;

prefixUnaryOperation
  : "-" : "+"
  : "++" : "--"
  : "!"  // No ~
  ;

postfixUnaryOperation
  : "++" : "--"
  ;

functionCall
  : functionExpression typeArguments valueArguments? functionLiteral?
  : functionExpression valueArguments functionLiteral?
  ;

functionExpression
  : expression
  ;

typeArguments
  : "<" type{","} ">"
  ;

valueArguments
  : "(" (SimpleName "=")? ("out" | "ref")? expression{","} ")"
  ;

infixFunctionCall
  : expression SimpleName typeArguments expression?
  : expression SimpleName expression
  ;

jump
  : "throw" expression
  : "return" expression?
  : "continue" SimpleName
  : "break" SimpleName
// yield ?
  ;

tupleLiteral // Ambiguity when after a SimpleName (infix call). In this case (e) is treated as an expression in parentheses
             // to put a tuple, write write ((e))
  : "(" expression{","} ")"
  ;

functionLiteral  // one can use "it" as a parameter name
  : "{" expressions "}"
  : "{" (type ".")? modifiers SimpleName "=>" expressions "}"
  : "{" (type ".")? "(" (modifiers SimpleName (":" type)?){","} ")" (":" type)? "=>" expressions "}"
  ;

expressions
  : expression{SEMI} SEMI?
  ;

constructorInvocation
  : userType valueArguments?
  ;

memberAccess
  : functionCall
  : fieldOrPropertyAccess
  : functionLiteral // no parameters allowed
  ;

fieldOrPropertyAccess
  : (FieldName | SimpleName) arrayAccess?
  ;

arrayAccess
  : "[" expression "]"
  ;

objectLiteral
  : "object" delegationSpecifier{","}? classBody // Cannot make class body optional: foo(object F, a)
  ;

/* Factory methods:

objectLiteral
  : "object" delegationSpecifier{","} ("{" objectLiteralMember{","} "}")?
  ;

objectLiteralMember
  : memberDeclaration
  : factoryMethod
  ;

factoryMethod
  : accessModifier? SimpleName typeParameters? functionParameters functionBody
  ;

*/
