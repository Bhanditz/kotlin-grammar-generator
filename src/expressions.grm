/*
Decreasing precedence:
  memberAccessOperation
  postfixUnaryOperation
  prefixUnaryOperation
  multiplicativeOperation
  additiveOperation
  ".."
  SimpleName
  "?:"
  namedInfixOrTypeOperation
  comparisonOperation
  equalityOperation
  "&&"
  "||"
  "->"
  assignmentOperator
*/


expression
  : arrowTupleExpression (assignmentOperator arrowTupleExpression)?
  ;

arrowTupleExpression
  : assignmentOperator ("->" assignmentOperator)*
  ;

disjunction
  : conjunction ("||" conjunction)*
  ;

conjunction
  : equalityComparison ("&&" equalityComparison)*
  ;

equalityComparison
  : comparison (equalityOperation comparison)*
  ;

comparison
  : namedInfixOrTypeExpression (comparisonOperation namedInfixOrTypeExpression)*
  ;

namedInfixOrTypeExpression
  : elvisExpression (inOperation elvisExpression)*
  : elvisExpression (isOperation isRHS)?
  : elvisExpression (typeOperation type)?
  ;

elvisExpression
  : infixFunctionCall ("?:" infixFunctionCall)*
  ;

infixFunctionCall
  : rangeExpression (SimpleName rangeExpression)*
  ;

rangeExpression
  : additiveExpression (".." additiveExpression)*
  ;

additiveExpression
  : multiplicativeExpression (additiveOperation multiplicativeExpression)*
  ;

multiplicativeExpression
  : prefixUnaryExpression (multiplicativeOperation prefixUnaryExpression)*
  ;

prefixUnaryExpression
  : prefixUnaryOperation* postfixUnaryExpression
  ;

postfixUnaryExpression
  : atomicExpression postfixUnaryOperation*
  ;

// !!! When you add here, remember to update the FIRST set in the parser
atomicExpression
  : "(" expression ")" // see tupleLiteral
  : literalConstant
  : functionLiteral
  : tupleLiteral
  : "this" label? ("<" type ">")?
  : if
  : when
  : try
  : "typeof" "(" expression ")"
  : "new" constructorInvocation
  : objectLiteral
  : declaration
  : jump
  : loop
  : SimpleName
  : FieldName
  : "namespace" // for the root namespace
  ;

label
  : "@"
  : "@@"
  : LabelName
  ;

literalConstant
  : "true" | "false"
  : StringWithTemplates
  : NoEscapeString
  : IntegerLiteral
  : LongLiteral
  : CharacterLiteral
  : FloatLiteral
  : "null"
  ;

isRHS
  : pattern
  ;

declaration
  : function
  : property
  : extension
  : class
  : typedef
  ;

multiplicativeOperation
  : "*" : "/" : "%"
  ;

additiveOperation
  : "+" : "-"
  ;

inOperation
  : "in" : "!in"
  ;

typeOperation
  : "as" : ":"
  ;

isOPeration
  : "is" : "!is"
  ;

comparisonOperation
  : "<" : ">" : ">=" : "<="
  ;

equalityOperation
  : "!=" : "==" : "===" : "!=="
  ;

assignmentOperator
  : "="
  : "+=" : "-=" : "*=" : "/=" : "%="
  ;

unOpExpression
  : expression postfixUnaryOperation
  : prefixUnaryOperation expression
  ;

prefixUnaryOperation
  : "-" : "+"
  : "++" : "--"
  : "!"  // No ~
  : attributes // mandatory
  : label
  ;

postfixUnaryOperation
  : "++" : "--"
  : typeArguments? valueArguments (label? functionLiteral)
  : typeArguments (label? functionLiteral)
  : arrayAccess
  : memberAccessOperation postfixUnaryOperation // TODO: Review
  ;

memberAccessOperation
  : "." : "?." : "#" : "?"
  ;

typeArguments
  : "<" type{","} ">"
  ;

valueArguments
  : "(" (SimpleName "=")? ("out" | "ref")? expression{","} ")"
  ;

jump
  : "throw" expression
  : "return" label? expression?
  : "continue" label?
  : "break" label?
// yield ?
  ;

stringLiteral
  : StringWithTemplates
  : NoEscapeString
  ;

tupleLiteral // Ambiguity when after a SimpleName (infix call). In this case (e) is treated as an expression in parentheses
             // to put a tuple, write write ((e))
  : "(" ((SimpleName "=")? expression){","} ")"
  ;

functionLiteral  // one can use "it" as a parameter name
  : "{" expressions "}"
  : "{" (type ".")? modifiers SimpleName "=>" expressions "}"
  : "{" (type ".")? "(" (modifiers SimpleName (":" type)?){","} ")" (":" type)? "=>" expressions "}"
  ;

expressions
  : SEMI* expression{SEMI+} SEMI*
  ;

constructorInvocation
  : userType valueArguments
  ;

arrayAccess
  : "[" expression{","} "]"
  ;

objectLiteral
  : "object" delegationSpecifier{","}? classBody // Cannot make class body optional: foo(object F, a)
  ;

/* Factory methods:

objectLiteral
  : "object" delegationSpecifier{","} ("{" objectLiteralMember{","} "}")?
  ;

objectLiteralMember
  : memberDeclaration
  : factoryMethod
  ;

factoryMethod
  : accessModifier? SimpleName typeParameters? functionParameters functionBody
  ;

*/
