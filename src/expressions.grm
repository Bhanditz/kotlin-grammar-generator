expression
  : "(" expression ")" // see tupleLiteral
  : literalConstant
  : functionLiteral
  : tupleLiteral
  : listLiteral
  : mapLiteral
  : "null"
  : "this"
  : memberAccessExpression
  : infixFunctionCall
  : binOpExpression
  : assignment
  : unOpExpression
  : castExpression
  : match
  : if
  : "new" constructorInvocation
  : anonymousInnerClassInstantiation // TODO
// TODO: list comprehension
  : jump
  ;

castExpression
  : expression "as" type
  ;

binOpExpression
  : expression binaryOperation expression // see priorities
  ;

unOpExpression
  : expression postfixUnaryOperation
  : prefixUnaryOperation expression
  ;

binaryOperation // Decreasing precedence
  : "*" : "/"    // No %
  : "+" : "-"
  // No << >> >>>
  : "<" : ">" : ">=" : "<=" : "is" : "isnot" : "in" // TODO: Check the precedence for in carefully
  : "!=" : "==" : "==="
  // No | & ^ ~
  : "&&"
  : "||"
  ;

assignmentOperator
  : "="
  : "+=" : "-=" : "*=" : "/=" // TODO: |=, %= and <<= make more sense than |, % or << alone, and so for others
  ;

assignment
  : memberAccessExpression assignmentOperator expression // Assignment to functions prohibited by a semantic check
  ;

prefixUnaryOperation
  : "-" : "+"
  : "++" : "--"
  : "!"  // No ~
  ;

postfixUnaryOperation
  : "++" : "--"
  ;

functionCall
  : SimpleName typeArguments valueArguments? functionLiteral?
  : SimpleName valueArguments functionLiteral?
  ;

typeArguments
  : "<" type{","} ">"
  ;

valueArguments
  : "(" expression{","} ")"
  ;

infixFunctionCall
  : expression SimpleName typeArguments expression?
  : expression SimpleName expression
  ;

jump
  : "throw" expression
  : "return" expression
  : "continue" SimpleName
  : "break" SimpleName
// yield ?
  ;

tupleLiteral // Ambiguity when after a SimpleName (infix call). In this case (e) is treated as an expression in parentheses
             // to put a tuple, write write ((e))
  : "(" expression{","} ")"
  ;

functionLiteral
  : "{" SimpleName "=>" expression "}"
  : "{" functionTypeContents "=>" expression "}"
  : "{" "(" parameter{","} ")" "=>" expression "}"
  ;

constructorInvocation
  : userType "(" expression{","} ")"
  ;

listLiteral
  : "[" expression{","} "]"
  ;

mapLiteral
  : "[" mapEntryLiteral ("," mapEntryLiteral)* "]"
  : "[" ":" "]"
  ;

mapEntryLiteral
  : expression ":" expression
  ;

literalConstant
  : booleanLiteral
  : IntegerLiteral
  : HexadecimalLiteral
  : CharacterLiteral
  : SingleLineStringLiteral
  : SingleLineStringTemplate
  : MultiLineStringLiteral
  : MultiLineStringTemplate
  ;

memberAccessExpression
  : (expression ".")? memberAccess
  ;

memberAccess
  : functionCall
  : fieldOrPropertyAccess
  ;

fieldOrPropertyAccess
  : (FieldName | SimpleName) arrayAccess?
  ;

arrayAccess
  : "[" expression "]"
  ;