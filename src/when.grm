when
  : "when" "(" (modifiers "val" SimpleName "=")? expression ")" "{"
        whenEntry*
    "}"
  ;

whenEntry
  // TODO : consider empty after =>
  : whenConditionIf{","} (when  | "=>" expression SEMI)
  : "else" ("continue" | "=>" expression SEMI)
  ;

whenConditionIf
  : whenCondition ("if" "(" expression ")")?
  ;

whenCondition
  : expression
  : "." atomicExpression typeArguments? valueArguments?
  : ("in" | "!in") expression
  : ("is" | "!is") isRHS
  ;

pattern
  : attributes pattern
  : type // '[a] T' is a type-pattern 'T' with an attribute '[a]', not a type-pattern '[a] T'
         // this makes sense because is-check may be different for a type with attributes
  : tuplePattern
  : decomposerPattern
  : constantPattern
  : bindingPattern
  : "*" // wildcard pattern
  ;

decomposerPattern
  : type
// TODO : typeParameters will be consumed by the expression
  : elvisExpression typeParameters? '@' tuplePattern
  ;

constantPattern
  : literalConstant
  ;

tuplePattern
  : "(" ((SimpleName "=")? pattern{","})? ")"
  ;

bindingPattern
  : "val" SimpleName binding?
  ;

binding
  : "is" pattern
  : "!is" pattern
  : "in" expression
  : "!in" expression
  : ":" type
  ;